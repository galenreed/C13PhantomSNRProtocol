function [reconImage] = fftAndZeroPad(inputData, params, header)  % fftAndZeroPad  % written by Galen Reed 09/18  % this is a simple routine to recunstruct output MRSI data from fidcsi.e  % frequency domain filtering, and kx and ky zero padding are applied  %  %  % input data should be parsed as (freq, phase) or (freq, phase, coils)   % windowWidth, expressed as a fraction of the FID duration, is the width of the freq domain filter   % integrationWindow, expressed as a fraction of the spect width, is the amount  %       of points, centered at resonance, over which to integrate to generate an image      %  % read headers, define FID filter and t, f, domains  %       dataSize = size(inputData);  nc = 0;  if(length(dataSize) == 2)    nc = 1;  else    nc = dataSize(3);  end    nx = round(sqrt(dataSize(1)));    nf = dataSize(2);  ny = nx; % hopefully these are the same    disp(['frequency samples = ', num2str(nf)]);  disp(['X samples = ', num2str(nx)]);  disp(['Y samples = ', num2str(ny)]);  disp(['channels = ', num2str(nc)]);      sweepWidth = header.image.user0;  FIDTimeDomain = linspace(0, nf/sweepWidth, nf);  fidWindow = exp(-FIDTimeDomain * params.lineBroadening);  freqDomain = linspace(-sweepWidth/2, sweepWidth/2, nf);  integrationPoints = round((params.integrationWindow /sweepWidth)* nf);  lb = nf/2 - round(integrationPoints/2);  ub = nf/2 + round(integrationPoints/2);  integrationBounds = [lb,ub];    %  % step 1: parse, compensate for RF chopping  %        apodizedData = zeros([nf, nx, ny, nc]);  summedFIDs = zeros([1 nf]);  summedApodizedFIDs = zeros([1 nf]);    for kk = 1:nc    for ii = 1:ny      for jj = 1:nx        ind = jj + (ii-1)*ny;                %NOTE: FIDcsi adds RF chopping when opnex>1        %an improvement would be to only perform this correction        % if the header indicates nex>1        rfChopping = (-1)^ind;        thisFid = squeeze(inputData(ind, :, kk)) * rfChopping;                % window the FID with a filter.         apodizedFID = thisFid .* fidWindow;        apodizedData(:,jj,ii,kk) = apodizedFID;                summedFIDs = summedFIDs + thisFid;        summedApodizedFIDs = summedApodizedFIDs + apodizedFID;      end    end  end        %  % step 2: zero pad spatial dimensions (2X)  %  zeroPaddedData = padarray(apodizedData, [0 nx/2 ny/2 0], 0, 'both');   %  % step 3: FFT each dimension (aside from coils)    %  fftData = zeros(size(zeroPaddedData));  for kk = 1:nc    singleCoilData = squeeze(zeroPaddedData(:, :, :, kk));    singleCoilFFTData = fftnc(singleCoilData);    fftData(:, :, :, kk) = singleCoilFFTData;  end    %  % step 4: take a window about the midpoint of spectra, add these points  %  integratedData = zeros([nx ny nc]);  totalSpec = zeros([nf 1]);  for kk = 1:nc    for ii = 1:2*ny      for jj = 1:2*nx        thisSpec = abs(squeeze(fftData(:, jj, ii, kk)));        specInsideWindow = thisSpec(lb:ub);        summedSpec = squeeze(sum(specInsideWindow));        integratedData(jj, ii, kk) = summedSpec;                totalSpec = totalSpec + thisSpec;      end    end  end      if(params.doPlot == 1)        mask = max(totalSpec)*ones(size(totalSpec));    mask(1:lb-1) = min(totalSpec);    mask(ub+1:end) = min(totalSpec);    figure();    plot(freqDomain, totalSpec,...         freqDomain, mask);    xlabel('freq [Hz]');         legend('summed spec', 'integration mask');    end    reconImage = integratedData; end